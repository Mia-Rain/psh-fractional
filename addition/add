#!/bin/sh
# add $2 to $1 and return
[ -z "${1##*.*}" -o -z "${2##*.*}" ] && { # if float # dylanaraps/pure-sh-bible#check-if-a-number-is-a-float 
  # modified to check $1 & $2
  # make sure $1 & $2 are the same length
  if [ "${#1}" -gt "${#2}" ]; then
    f2="${2##*.}"; f1="${1##*.}"; until [ "${#f2}" -eq "${#f1}" ]; do
      f2="${f2}0"
    done
    set -- "$1" "${2%%.*}.$f2"
  elif [ "${#1}" -lt "${#2}" ]; then
    f1="${1##*.}"; f2="${2##*.}"; until [ "${#f1}" -eq "${#f2}" ]; do
      f1="${f1}0"
    done
    set -- "${1%%.*}.$f1" "$2"
  fi   
  until [ "${#1}" -ge "${#2}" ]; do
    set -- "0$1" "$2"
  done
  until [ "${#2}" -ge "${#1}" ]; do
    set -- "$1" "0$2"
  done
  #echo "$1 $2"
  f1="${1##*.}"; f2="${2##*.}" # whole is ${1%.$f1} # dot required
  # eq is $1+$2 -- $f1 + $f2 -- then add $1 & $2
  wo="$((${1%.$f1}+${2%.$f2}))" # whole digit, this is preset and not redeclared
  # this is because we may need to carry
  while [ "$f1" ]; do
    while [ "$f2" ]; do
      next2="${f2#?}"; next1="${f1#?}"
      [ "$((${f1%$next1} + ${f2%$next2}))" -gt 9 ] && {
        oo="$o"; [ "$o" ] && {
          : $((oo+=1))
        } || : $((wo+=1))
        o="$((${f1%$next1} + ${f2%$next2}))"; o="${o#?}"; o="$oo$o"; unset oo # unset to save ram
      } || o="$o$((${f1%$next1} + ${f2%$next2}))"
      f2="$next2"; f1="${next1}" 
    done
  done
  echo "$wo.${o:-0}"
} || { # if not just do basic addition
  echo $(($1+$2))
}
