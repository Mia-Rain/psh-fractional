#!/bin/sh
# add $2 to $1 and return
# shellcheck disable=SC2086,SC2046,SC2166,SC2015
[ -z "${1##*.*}" -o -z "${2##*.*}" ] && { # if float # dylanaraps/pure-sh-bible#check-if-a-number-is-a-float 
  # modified to check $1 & $2
  if [ -n "${1##*.*}" ]; then
    set -- "${1}.0" "$2"; d="${1#*.}"; d2="${2#*.}"
    until [ "${#d}" -eq "${#d2}" ]; do
      set -- "${1}0" "$2"
      d="${1#*.}"
    done
  elif [ -n "${2##*.*}" ]; then
    set -- "$1" "${2}.0"; d="${2#*.}"; d2="${1#*.}"
    until [ "${#d}" -eq "${#d2}" ]; do
      set -- "$1" "${2}0"
      d="${2#*.}"
    done
  fi # if $1/$2 is not a float; convert to float
  until [ "${#1}" -ge "${#2}" ]; do
    set -- "0$1" "$2"
  done
  until [ "${#2}" -ge "${#1}" ]; do
    set -- "$1" "0$2"
  done
  #echo "$1 $2"
  f1="${1##*.}"; f2="${2##*.}" # whole is ${1%.$f1} # dot required
  # eq is $1+$2 -- $f1 + $f2 -- then add $1 & $2
  w1="${1%."$f1"}"; w2="${2%."$f2"}"
  until [ "${w1#0}" = "$w1" ]; do
    w1="${w1#0}"
  done
  until [ "${w2#0}" = "$w2" ]; do
    w2="${w2#0}"
  done # dash has issues when numbers have leading 0's
  w1="${w1#0}"; w2="${w2#0}"
  wo="$((${w1:-0}+${w2:-0}))" # whole digit, this is preset and not redeclared
  # this is because we may need to carry
  ##
  # $(()) has issues with numbers that start with a 0
  # this is because $(()) can operate in various different bases - see psh-prng
  # to prevent this, the leading 0 must be removed before $(()) it used, and added back after
  # this typically results in a painful mess of carrying
  ## 
  o="$((f1+f2))"
  ## there is a major bug here ^
  if [ "${#f1}" -ge "${#f2}" ]; then
    l="${#f1}"
  elif [ "${#f2}" -ge "${#f1}" ]; then
    l="${#f2}"
  fi
  [ "${#o}" -gt "${l}" ] && {
    ol=$((${#o}-l)); old="${o}"; until [ "${#old}" -eq "${ol}" ]; do
      old="${old%?}"
    done
    : $((wo+=old))
    o="${o#"$old"}"
  }
  echo "$wo.${o:-0}"
} || { # if not just do basic addition
  echo $(($1+$2))
}
